"""
Module to generate domains using DGAs

Extra libraries are required to use some DGAs
"""
import argparse
import glob
import math
import os
import pathlib
import random
import subprocess
from itertools import chain


class GenerateDGA:
    """Class to generate domains"""

    _org_path = f"{os.getcwd()}/"
    _files = list(glob.glob("generators/**/dga*.py", recursive=True))
    _dict_based = ["gozi", "nymaim2", "pizd", "suppobox"]
    _fixed = [
        "bazarbackdoor",
        "chinad",
        "locky/dgav2.py",
        "orchard",
        "padcrypt",
        "pitou",
        "pushdo",
        "qsnatch",
        "ranbyus",
        "sharkbot",
        "sisron",
        "tempedreve",
        "tinba",
        "unnamed_downloader",
        "verblecon",
    ]
    _multiple_scripts = [
        "bazarbackdoor",
        "kraken",
        "locky",
        "m0yv",
        "murofet",
        "necurs",
        "pykspa",
        "qsnatch",
        "vawtrak",
    ]

    ###
    # Number of samples: Final number of generated domains by each algorithm
    #                    to be written to a .txt file
    # Gen num: Initial number of domains to be generated by each algorithm
    #          before being sampled again for the final output
    # NOTE: Gen num >= Number of samples
    ###
    def __init__(self, python_path, number_of_samples, gen_num=None, output_dir=None):
        self._domain_list = []
        self._multiple_list = []
        self._number_of_samples = number_of_samples
        self._python_path = python_path
        self._gen_num = gen_num
        self._output_dir = output_dir
        if not os.path.isabs(self._python_path):
            self._python_path = f"{os.path.abspath('')}/{self._python_path}"
        if not self._output_dir:
            self._output_dir = ""
        else:
            if not self._output_dir.endswith("\\") or not self._output_dir.endswith(
                "/"
            ):
                self._output_dir = f"{self._output_dir}/"
            if not os.path.isdir(self._output_dir):
                os.makedirs(self._output_dir)
        if self._gen_num:
            if self._gen_num < self._number_of_samples:
                print(
                    "Number of domains to be generate is smaller than number of samples\n"
                    "Changing it to",
                    self._number_of_samples,
                )
        if not self._gen_num or self._gen_num < self._number_of_samples:
            self._gen_num = self._number_of_samples

    def get_dict_based(self):
        """Get random dict based domains."""
        print("Generating dict based domains...")
        for file in self._files:
            if not any(dict_algo in file for dict_algo in self._dict_based):
                continue
            print(file)
            self._exec_dict_based(pathlib.PurePath(file).as_posix())
        domain_list_expanded = list(chain.from_iterable(self._domain_list))
        self._write_to_file(
            domain_list_expanded,
            f"{self._output_dir}attack_dict_based_{self._number_of_samples}_each.txt",
        )
        self._domain_list.clear()

    def get_char_based(self):
        """Get random char based domains"""
        self._gen_char_based()
        domain_list_expanded = list(chain.from_iterable(self._domain_list))
        self._write_to_file(
            domain_list_expanded,
            f"{self._output_dir}attack_char_based_{self._number_of_samples}_each.txt",
        )
        self._domain_list.clear()

    def get_char_based_mutually_exclusive(self, number_of_files):
        """
        Get random char based domains and divide them into files.
        The algorithms between files are mutually exclusive to each other.
        Please be aware that some scripts in this algorithm are hardcoded
        and may not generate enough samples from an arbitrary number.
        Number of samples in the final .txt file can be less than expected.
        """
        self._gen_char_based()
        algo_per_file = math.floor(len(self._domain_list) / number_of_files)
        remain = len(self._domain_list) % number_of_files
        algo_per_file_list = []
        for index in range(number_of_files):
            if index < remain:
                algo_per_file_list.append(algo_per_file + 1)
            else:
                algo_per_file_list.append(algo_per_file)
        random.shuffle(algo_per_file_list)
        for index in range(number_of_files):
            temp_list = list(
                chain.from_iterable(
                    self._domain_list.pop(random.randrange(len(self._domain_list)))
                    for _ in range(algo_per_file_list[index])
                )
            )
            self._write_to_file(
                temp_list,
                f"{self._output_dir}attack_char_based_mutually_exclusive_"
                f"{str(index+1).zfill(2)}.txt",
            )
        self._domain_list.clear()

    def get_algorithm(self, algo_name, number_of_files):
        """Get attack domains by algorithm name"""
        samples_per_file = math.ceil(self._number_of_samples / number_of_files)
        algo_list = os.listdir("generators")
        if algo_name not in algo_list:
            print("Algorithm doesn't exist. Please check again!")
            return
        print(f"Generating {algo_name} domains...")
        if algo_name in self._fixed:
            print(
                "Please be aware that some scripts in this algorithm are hardcoded "
                "and may not generate enough samples from an arbitrary number.\n"
                "Number of generated files can be less than expected."
            )
        for file in self._files:
            if algo_name in file:
                print(file)
                if algo_name not in self._dict_based:
                    self._exec_char_based(pathlib.PurePath(file).as_posix())
                else:
                    self._exec_dict_based(pathlib.PurePath(file).as_posix())
        if self._multiple_list:
            self._process_multiple()
        if len(self._domain_list[0]) < self._number_of_samples:
            number_of_files = math.ceil(len(self._domain_list[0]) / samples_per_file)
        for index in range(number_of_files):
            temp_list = self._domain_list[0][
                index * samples_per_file : (index + 1) * samples_per_file
            ]
            self._write_to_file(
                temp_list,
                f"{self._output_dir}{algo_name}_{samples_per_file}_"
                f"{str(index+1).zfill(2)}_.txt",
            )
        self._domain_list.clear()

    def _run_algorithm(self, arguments, file):
        """Run each algorithm script"""
        command_list = [self._python_path, os.path.basename(file)]
        command_list.extend(arguments)
        os.chdir(self._org_path + os.path.dirname(file))
        with subprocess.Popen(command_list, stdout=subprocess.PIPE) as proc:
            out = proc.communicate()[0]
        if os.name == "nt":
            temp_domain_list = out.decode("utf-8").split("\r\n")
        else:
            temp_domain_list = out.decode("utf-8").split("\n")
        temp_domain_list.pop()
        init_len = len(temp_domain_list)
        temp_domain_list = list(dict.fromkeys(temp_domain_list))
        final_len = len(temp_domain_list)
        if final_len >= self._number_of_samples:
            temp_domain_list = random.sample(temp_domain_list, self._number_of_samples)
        else:
            if not any(fixed_algo in file for fixed_algo in self._fixed):
                not_enough_warn = f"Generated: {len(temp_domain_list)}. "
                if init_len >= self._number_of_samples:
                    not_enough_warn += (
                        "Was sufficient initially but was reduced due to "
                        "removing duplicate domains."
                    )
                else:
                    not_enough_warn += "Insufficient number of domains."
                print(not_enough_warn)
        if any(multiple_algo in file for multiple_algo in self._multiple_scripts):
            self._multiple_list.extend(temp_domain_list)
        else:
            self._domain_list.append(temp_domain_list)

    def _exec_dict_based(self, file):
        """
        Execute the corresponding dict based script.\n
        This function evaluates algorithm name and execute with corresponding params.
        """
        if "suppobox" in file:
            self._run_algorithm(
                [str(random.randint(1, 3)), "-n", str(self._gen_num)], file
            )
            return
        self._run_algorithm(["-n", str(self._gen_num)], file)

    def _write_to_file(self, domain_list, output_name):
        """Write the generated samples to a text file"""
        os.chdir(self._org_path)
        with open(output_name, "w", encoding="utf-8") as file:
            for element in domain_list:
                file.write(f"{element}\n")

    def _gen_char_based(self):
        """Generate random char based domains"""
        print("Generating char based domains...")
        current_multiple = None
        for file in self._files:
            which_mul = (
                algo
                if any(
                    (algo := multiple_algo) in file
                    for multiple_algo in self._multiple_scripts
                )
                else None
            )
            if current_multiple != which_mul:
                if self._multiple_list:
                    self._process_multiple()
                current_multiple = which_mul
            if any(dict_algo in file for dict_algo in self._dict_based):
                continue
            print(file)
            self._exec_char_based(pathlib.PurePath(file).as_posix())

    def _exec_char_based(self, file):
        """
        Execute the corresponding char based script.\n
        This function evaluates algorithm name and execute with corresponding params.
        """
        if "fobber" in file:
            self._run_algorithm(
                [str(random.randint(1, 2)), "-n", str(self._gen_num)], file
            )
            return
        if "shiotob" in file:
            os.chdir(self._org_path)
            with open("benign.txt", "r", encoding="utf-8") as temp_file:
                while random.randrange(self._gen_num):
                    temp_file.readline()
                seed_domain = temp_file.readline().rstrip("\n")
            self._run_algorithm([seed_domain, "-n", str(self._gen_num)], file)
            return
        if "unknown_malware" in file:
            self._run_algorithm(
                [random.choice(["sn", "al"]), "-n", str(self._gen_num)], file
            )
            return
        if any(
            algo in file
            for algo in ["dircrypt", "dnschanger", "ramnit", "vawtrak/dga.py"]
        ):
            self._run_algorithm(
                [hex(random.randint(0, self._gen_num)), "-n", str(self._gen_num)], file
            )
            return
        if any(fixed_algo in file for fixed_algo in self._fixed):
            self._run_algorithm([], file)
            return
        self._run_algorithm(["-n", str(self._gen_num)], file)

    def _process_multiple(self):
        """Process algorithms that have multiple scripts"""
        if len(self._multiple_list) >= self._number_of_samples:
            self._domain_list.append(
                random.sample(self._multiple_list, self._number_of_samples)
            )
        else:
            print(
                f"Multi-scripts Generated: {len(self._multiple_list)}. "
                "Insufficient number of domains."
            )
            self._domain_list.append(self._multiple_list)
        self._multiple_list.clear()


def main():
    """Main function"""
    parser = argparse.ArgumentParser(
        description="Generate DGAs randomly",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )
    parser.add_argument("samples", type=int, help="samples per algorithm")
    parser.add_argument(
        "--py_path",
        help="python path to run algorithm scripts, helpful for virtual environments",
        default="/usr/bin/python3.9",
    )
    parser.add_argument(
        "--init_num",
        help="initial number of generated domains before being randomly sampled again",
        type=int,
    )
    parser.add_argument(
        "--out_dir",
        help="output directory of the generated domains",
        default="Client/train_file/",
    )
    extended = parser.add_argument_group("extended functions")
    extended.add_argument("--algo", help="algorithm to generate attack domains")
    extended.add_argument(
        "--file_num",
        help="number of files to be divided into, usually goes with --algo. "
        "If it is specified alone, the script will generate char-based "
        "attack domains and divide them into files, the algorithms in "
        "all of which will be mutually exclusive to each other",
        type=int,
    )
    args = parser.parse_args()

    gen = GenerateDGA(args.py_path, args.samples, args.init_num, args.out_dir)
    if args.algo and args.file_num:
        gen.get_algorithm(args.algo, args.file_num)
        return
    if args.file_num:
        gen.get_char_based_mutually_exclusive(args.file_num)
        return
    if args.algo:
        parser.error("Both --algo and --file_num flags must be specified together.")
    gen.get_dict_based()
    gen.get_char_based()


if __name__ == "__main__":
    main()
